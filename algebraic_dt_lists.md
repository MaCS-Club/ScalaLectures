[Назад](https://macs-club.github.io/ScalaLectures/index)
## 2. Классы и алгебраические типы: Списки
### 2.1 Базовые особенности синтаксиса
Как и Java, Scala используетс стандартный синтаксис объявления класса:

```
class className{
  тело класса
}
```

однако в Scala есть ряд полезных ключевых слов, делающих описание классов более удобным и функциональным.

Вместо интерфейсов или шаблонов здесь используются _трейты_ (или _свойства_) объявляемые ключевым словом `trait`. При их объявлении может использоваться ключевое свойство `sealed` -- оно означает, что свойство можно будет имплементировать лишь в пределах файла, где оно объявлено (такое свойство называют _закрытым_). Например:

```
sealed trait List[+A]
```

объявлет закрытое свойство `List` не имеющее никаких методов и полей.

Запись `[+A]` -- означает, что наше свойство _ковариантно_, (о ко-, контр- и инвариантности можно прочитать в отдельной [заметке](https://macs-club.github.io/ScalaLectures/variance)), пока стоит это понимать так:


Если тип `A` наследуется от типа `B`, то тип `List[A]` наследуется от типа `List[B]`. (Короткая запись: `A<:B, следовательно List[A]<:List[B]`)


Запись
 
```
case class Cons[+A] (head:A, tail:List[A]) extends List[A]
```

говорит о том, что класс сразу будет создан с _первичным конструктором_ принимающим параметры `head` и `tail`, и одноименными полями. Таким образом класс служащий лишь для хранения данных может вообще не нуждаться в описании его тела. Про ключевое слово `case` будет сказано подробнее позже.

Его статические методы и поля или методы и поля могут быть описаны в одноименном объекте.
Напримр, следующие объект будет содержать методы для работы с нашим ранее упоминвшимся свойством `List`

```
object List{
}
```

которые в том числе будут применены к имплементации `Cons`.

Правильнее всего воспринимать `object` именно как некоторый синглтонный объект содержащий статические методы и поля класса или трейта, а не просто их описание. Пример такого подхода будет дан в следующем параграфе.

### 2.2 Алгебраические типы
Наиболее правильным с точки зрения функционального програмирования является определение нового типа в виде так называемого _алгебраического типа_.

Это описание состоит из определения закрытого трейта и нескольих его имплементаций начинающихся с ключевого слова `case`. Например список мы можем определить так:


```
sealed trait List[+A]
case object Nil extends List[Nothing]
case class Cons[+A] (head:A, tail:List[A]) extends List[A]

```

Где пустой список мы опредеяем как `object Nil extends List[Nothing]` используя `object` как определения синглтона. Таким образом в памяти всегда будет существовать всегда один объект пустого списка, включеный в каждый другой список, что логично с алгебраической точки зрения (существует единственное пустое множество) и экономит память. Тип `Nothing` -- минимальный общий тип, который наследуется от каждого другого типа типа. Таким образом, так как мы объявили `List` ковариантом, то `Nil` будет наследником списка каждого типа.

Вторая имплементация, которую мы уже видели описывают конструктор списка, который содержит в себе элемент типа `A` -- голову списка и хвост списка, который сам является списком элементов типа `A` (возможно пустым). Таким образом мы строим список рекурсивно, например список из числе `1`, `2` и `3` будет иметь вид

```
Cons(1,Cons(2,Cons(3,Nil)))
```

Особенность алгебраических типов -- к ним можно применять _сравнивание по образцу_, оно имеет следующий синтаксис
```
value match {
  case Case1 => Eval1
  case Case2 => Eval2
  ...
  case CaseN => EvalN
}
```

где `value` -- проверяемое значение, написаные между `case` и `=>` выражения -- образцы имеющие вид литералов, переменных (которые можно использовать в правой части полсе `=>`) и конструкторы данных с которыми сравнивается проверяемое значения. В случае его первого совпадения с образцом будет вычеслена правая часть после `=>` и оператор вернет её.

Например используя сопоставляени с образцом можно написать функцию умножения чисел с плавующей точкой для нашего списка:

```
  def sum(ints: List[Int]): Int = ints match {
    case Nil => 0
    case Cons(x, xs) => x + sum(xs)
  }
```

где `_` -- обозначение для любого значения. Например, `case _` выполниться всегда, если сравнение дойдет до этого варианта.
## Пример: листинг списка
Пример имплементации списка, по которому будут выполнятся домашние упражнения.

```
sealed trait List[+A]
case object Nil extends List[Nothing]
case class Cons[+A] (head:A, tail:List[A]) extends List[A]


object List{
  def sum(ints: List[Int]): Int = ints match {
    case Nil => 0
    case Cons(x, xs) => x + sum(xs)
  }
  def product(ds: List[Double]): Double = ds match {
    case Nil => 1.0
    case Cons(0.0, _) => 0.0
    case Cons(x, xs) => x* product(xs)
  }
  def apply[A](as: A*): List[A] = 
    if (as.isEmpty) Nil
    else Cons(as.head, apply(as.tail: _*))

``` 

Здесь функция `apply` -- функция позволяющая переопределить применение типа. Это значит, что мы можем записывать в коде вызов `someType.apply(a,b,c)` просто как `someType(a,b,c)`. Таким образом, чтобы объявить список нам достаточно будет написать что-то вроде:

```
val ls = List("foo","bar","foobar")

```

И мы получим, что 


```
ls=Cons("foo",Cons("bar",Cons("foobar",Nil)))
```
[Назад](https://macs-club.github.io/ScalaLectures/index)

