[Назад](https://macs-club.github.io/ScalaLectures/index)
## 1. Основы и рекурсия
### 1.1: Обьявления 
- `var number :Int = 5` -- переменная

- `val number :Int = 5` -- неизменяемое значение

- `def plusFive (x:Int) :Int = x+5` -- функция

- `def findFisrt[A] (as:Array[A], p=>Bollean):Int` -- полиморфная функция, где `A` -- значение в которое подставляет произвольный тип.

Тип данных (здесь :Int) при объявление писать не обязательно в общем случае, но желательно. Это необходимо для функций при рекурсинвных вызовах_

Основные типы данных с которыми мы работаем 

- `Int` -- целые числа, например `2`, `4`, `5`, `42` ,`-54006`

- `Double` -- числа с плавющей точкой (конечные десятичные дроби), например `2.4`, `5.42`, `-54.006`

- `String` -- строки, например `"foo"`, `"bar"`, `"String"`

- `Boolean` -- логический тип, имеет два типа `true` и `false`

- `Array[A}` -- список, элемнты в нем одного типа `A`, упорядочены, занумеровны от 0, например в `Array("foo", "bar", "foo")` 0 и 2-й элементы  = `"foo"`, а 1-й `"bar"`.

- `A=>B` -- функция из типа `A`  в тип `B`, например `(a:Int):Boolean= a>5` действует из целых чисел в логический тип
 
### 1.2: Управляющие конструкции
`if value then res1 else res 2` -- условный оператор, если `value` -- истина вычислит значение`res1`, иначе  -- `res2`

`while value repeatableFunction ` -- условный цикл, пока `value` -- истина будет вычислять значение `repeatableFunction`

Основные логические операторы при проверке >,  <,  >= , <=, ==, != -- больше, меньше, больше или равно, меньше или равно, равно, не равно.

Вместо цикла мы будем использовать рекурсию (вызов функции в ней самой), а еще чаще хвостовую рекурсию -- рекурсию в которой мы не делаем ничего кроме вызова функция. Последняя хороша тем, что в при компиляции преврващается в цикл и защищает нас от переполнения стека. 

Пример функции считающей факториал через хвостовую рекурсию:

```
def factorial (n:Int):Int={ 

  @annotation.tailrec
  
  def go (n: Int,acc:Int):Int =
  
    if (n<=0)  acc
    
    go(n-1,acc*n)
    
  go(n,1)
  
}
```


Где `@annotation.tailrec` обозначает для компилятора, что следующая функция написана в виде хвостовой рекурсии

`for (i <- 1 to 5) repeatedFunction` -- оператор `for` не совсем являющийся циклом. Он последовательно присваивает создает значение обозначеннные как `i` в примере и присваивает им значение от произвольной коллекции описанной после знака `<-` (здесь используется запись `1 to 5` вычисляющая последовательность из чисел от 1 до 5) котарая может быть использована в выражении repeatedFunction

Чаще всего `for` используется для создания новых коллекций вместе с ключевым словом `yeld` (и так его следует использовать). Добавленно перед вычисляемым выражением это слово означает что результат каждого вычисления добавится в новую коллекцию (на самом деле монаду, но об этом позже) того же типа, что и выражение после yeld, Например 

```
val a = Array(1, 2, 3, 4, 5)

for (e <- a) yield e % 2
```

где `%` -- оператор подсчета остатка от деления, вернет `Array(1, 0, 1, 0, 1)`

Оператор `for` может содержать в себе условия
`for (e <- a if e > 2) yield e` где `a` как в прошлом примере вернет `Array(3, 4, 5)`

## Пример
Пример полиморфной функции использующей хвостовую рекурсию, чтобы найти номер первого элемента массива удовлетовряющего условию. Полезно для домашнего задания

```
def findFirst[A] (as:Array[A], p:A=>Boolean):Int={ 

  @annotation.tailrec
  
  def loop (n: Int):Int =
  
    if (n>=as.length)  -1
    
    else if (p(as(n))) n
    
    else loop(n+1)
    
  loop(0)
  
}
```

Метод `length` возвращает длину массива, запись `as(n)` возвращает его элемент под номером `n`

[Назад](https://macs-club.github.io/ScalaLectures/index)
