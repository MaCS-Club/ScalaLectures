[Назад](https://macs-club.github.io/ScalaLectures/index)

Код примеров и лабораторные будет выкладываться [здесь](https://github.com/MaCS-Club/ScalaExercises)
В случае затрудний при реализации, посмотрите пункт _Проверка корректности_ после упражнений. Если вы в принципе не знакомы с функциональным программирование -- прочитайте этот пункт _перед_ выполнением упражнений.

*Правая свертка:* по аналогии с функциями описанными в объекте `List` напишите общую функцию высшего порядка последовательно применяющую функцию `f` к элементам списка.

`def foldRight[A,B](as: List[A], z: B)(f: (A, B) => B): B `

*Левая свертка:* будет ли рекурсия реализованная в правой свертке хвостовой? Можно ли написать функцию последовательной обработки списка используя `tailrec`? Попробуйте написать подобную функцию используя следующую сигнатуру.

`def foldLeft[A,B](as: List[A], z: B)(f: (B, A) => B): B`


\* Напишите метод переводящий одну свертку в другую. Используйте в нем только сигнатуры методов. Не используйте никаких сторонних методов и свойств списка.

##### Проверка корректности
_Для удобства здесь будет использоваться инфиксная запись функции от двух переменных т.е. вместо `f(a)(b)` будем писать `a f b`. Можете проверить самостоятельно, что синтаксис Scala также позволяет использовать подобную запись в коде._

Корректно реализованная правая свертка будет обрабатывать список `xs = List(a,b, .. ,x)` от хвоста к голове:

```
foldRight(xs,z)(f) = (a f (b f ( .. f (x z) )))
```

то есть "справо налево", откуда и название.

Левая свертка, соответсвенно должна применять функцию в обратном порядке, с левой части списка:

```
foldLeft(xs,z)(g) = (((z g a) g b) .. g x)
```


[Назад](https://macs-club.github.io/ScalaLectures/index)
