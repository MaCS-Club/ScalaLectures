[Назад](https://macs-club.github.io/ScalaLectures/index)
## Лабораторная 2: Обработка ошибок

Как и Java, Scala позволяет использовать обработку ошибок и исключений с помощью конструкции `try catch`:

```
try{
  ...
  throw new Exception("Some exception")
  ...
}
catch {case e: Exception => ...}
```

Блок `catch` по сути содержит pattern matching в стиле обработки алгебраических структур данных, который мы рассматривали в разделе о списках.

Однако данный подход имеет свои минусы:

* Нарушение ссылочной прозрачности. Выкинутое исключение зависит от контекста, в котором выполняется код (т.к. одно и то же исключение может обработываться по разному в разным блоках `catch`)

* Нарушение типизации. Тип функции (например `Int=>Int`) ничего не говорит об исключениях которые она может вернуть и о том, каков будет их тип.

Scala предлагает два решения основанных на том, чтобы возвращать особый тип способный содержать как результать корректной отработки, так и ошибочный результат (или отсутствие результата)

# Решение один. Фунция возвращает корректный результат или ничего: Класс Option.

Класс `Option[A]` -- это алгебраическая структура данных имеющая две реализации.

`Some(a)` хранящую некоторое значение типа `A`

`None` означающую пустое значение.

Его можно использовать для передачи данных, которые не обязательно могут быть получены.

Например представим себе класс который может хранить информацию о работнике, при этом у него не может быть непосредственного руководителя.

```
 case class Employee(name: String, department: String, manager: Option[String])
```

В этом случае сотрудники могут иметь вид `Employee("Joe", "Finances", Some("Julie"))` или `Employee("Mary", "IT", None)`.

Это удобно, например при работе с базами данных, которые могут возвращать пустые поля или результаты запросов. Такой подход удобнее чем `null`-значения в Java, так как `Option` можно обрабатывает используя конструкцию match case, в отличи от `null` обернутое в `Option` значение нельзя пропустить и забыть обработать. К тому же класс обладает рядом своих встроенных функций облегчающих работу.

* `map`, `flatMap`, `filter` и `foreach` работают абсолютно аналогично спискам -- применяют функцию на обернутом значением, проверяют его предикатом, вызывают на нем функцию с побочным эффектом. Это значит, что мы можем применять монадическое включения с помощью `for` также и к `Option`.

* `getOrElse[B>:A](default: => B): B` -- возвращает обернутое значение, если элемент не пуст, либо возвращает дефолтное значение `b` если элемент -- `None`.

Пример:

```
Some("Julie").getOrElse("CEO") 
```

выведет

```
"Julie"
```

, а

```
None.getOrElse("CEO") 
```

выведет

```
"CEO"
```

* `orElse[B>:A](ob: => Option[B]): Option[B]` -- соотносится с `getOrElse`, так же как `flatMap` с `map`. Он возвращает дефолтное или хранящееся значение обернутое в `Some`.

Пример:

```
Some("Julie").orElse(Some("CEO")) 
```

выведет

```
"Some(Julie)"
```

, а

```
None.orElse(Some("CEO")) 
```

выведет

```
"Some(CEO)"
```

**Задание:** Лабораторная находится в [гитхабе](https://github.com/MaCS-Club/ScalaExercises) в ветке `option`. Первое что нужно сделать -- написать описанные здесь стандартные функции.

Обратите внимание на новый синтаксис. Запись `[B>:A]` означает, что `B` должен быть предком `A` или самим `А`. Это необходимо так как `A` -- ковариант и следовательно не может находится в контрвариантной позиции (в параметрах метода). Это называется _нижней границей типа_ (_верхняя граница_ обозначается аналогично `[B<:A]` и действует наоборот)

Также здесь появилась запись `=>b` без указания параметров функции. Оно означает, что значение после `=>` вызвыается _по имени_, а не _по значению_, то есть вычисляется не когда впервые встречается в коде, а когда его становится необходимо использовать (в том числе возможно никогда). Подробнее про них будет в разделе про отложенные вычисления.


Следующее задание -- переписать метод `map2` через `for`.

Последнее задание -- написать два метода:

```
def sequence[A](a: List[Option[A]]): Option[List[A]] 

def traverse[A, B](a: List[A])(f: A => Option[B]): Option[List[B]]

```

Логика первого -- преобразование списка опциональных значений в опциональный список. В случае если список содержит хоть один `None` результат тоже будет `None`. Второй применяет на списке функцию способную вернуть `None` и склеивает результат в опциональный список аналогично первому методу.

Все задания должны быть покрыты тестами.

# Решение два. Фунция возвращает корректный результат или объект ошибки: Класс Either.

Аналогично со структурой `Option[A]` можно рассмотреть структуру `Either[E,A]`.

Её отличие в том, что вместо `None` в качетсве вывода неверного результата она используется так называемое левое значение, имеющее вид `Left(e)`, где `e:E`. Вместо `Some(a)`, она соответственно возвращает `Right(a)`. `E` может быть любым типом, например строкой с сообщением об ошибке, кодом ошибки, объектом исключения.

Отличие этого типа от просто пары значений, в том, что он не симметричен. Стандартные функции `map`, `flatMap`, `filter` обрабатывают только правое значение оставляя левое значение без изменений. Набор основных функций практически совпадает с функциями `Option` и отдельно рассматриваться не будет.

**Задание:** Лабораторная находится в [гитхабе](https://github.com/MaCS-Club/ScalaExercises) в ветке `either`. Она короче чем `option`, так как большая часть методов реализованы и покрыты тестами. Нужно лишь добавить реализации методов `sequence` и `traverse` по аналогии с прошлой лабораторной.

[Назад](https://macs-club.github.io/ScalaLectures/index)
