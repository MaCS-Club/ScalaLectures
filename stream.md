[Назад](https://macs-club.github.io/ScalaLectures/index)
## Лабораторная 3: Отложенные вычисления

Рассмотрим следующую последовательность действий над списком:

```
List(1,2,3,4) map(_+10) filter(_%2==0) map(_*3)
```

Можно заметить, что на каждом вызове функции мы пробегаемся по всему списку, применяя операцию. При больших объемах данных, это повышает затраты ресурсов и не позволяетраспаралелить вычисления. Гораздо удобнее было бы, если бы мы могли применить весь набор операций сначала к первому, затем ко второму и так далее -- к другим элементам списка. Но для этого нам нужно, чтобы работая с одним элементом списка, мы не вычисляли значении остальных. Тут на помощь приходят __ленивые__ или __отложенные вычисления__.

### Синтаксис отложенных вычислений в Scala

По умолчанию каждое значение в Scala вычисляется при инциализации.
Например:

```
val a = {println("text")}
```

выведет `text` при инциализации и дальше, при использовании значения этот побочных эффект не будет вызываться.

Простейшие способ объявить элемент отложенно -- объявить его как функцию без параметров:

```
val a = ()=>{println("text")}
```

В этом случае при каждом вызове `a()` будет выводится `text`. Иногда в этой записи `()` можно опустить. Таким образом при вызове никаких вычислений не производится, однако они производятся каждый раз когда вызывается `a`. Это не всегда удобн, и часто чтобы проводить вычсисления только при первом вызове значения используется ключевое слово `lazy`:

```
lazy val a = {println("text")}
```

В этом случае значение `text` выведется только при первом использовании значения `a`.

### Реализация Stream и корекурсия

Рассмотри реализацию `Stream` -- аналог односвязного списка использующий ленивые вычисления. Его реализация аналогична

```
trait Stream[+A]
case object Empty extends Stream[Nothing]
case class Cons[+A] (h: ()=>A,t: ()=>Stream[A]) extends Stream[A]
```

Как мы видим -- единственное отличие, это использование отложенных вычислений в конструкторе.
Чтобы не вызывать вычисление по несколько раз в объекте компаньене определен умный конструктор:

```
def cons[A](hd: => A,tl: => Stream[A]):Stream[A]={
  lazy val head = hd
  lazy val tail = tl
  Cons(()=>head,()=>tail)
}
def empty[A]:Stream[A]=Empty
```
Стоит заметить, что функция `foldRight` более безопасна для памяти при использовании отложенных вычислений, так как если она успеет отработать на первых данных, то дальнейшие значения просто не будут вызываться.

```
def foldRight[B](z: => B)(f: (A, => B) => B): B =
    this match {
      case Cons(h,t) => f(h(), t().foldRight(z)(f))
      case _ => z
    }
```

Одно из серьезных преимуществ отложенных вычислений -- возможность работы с коданными -- потенциально бесконечным аналогом обычных данныхю. На конструкции `Stream` можно реализовать __корекурсию__, которая в отличии от обычной рекурсии, способной свести сколь угодное количество данных к одному результату, производит сколь угодно много коданных из конечного стартового значения.

Простейший пример это ряд констант:

```
val a:Stream[String] = Stream.cons("a",a)
```

За счет отложенных вычислений конструктор может принять собственный результат и тем самым получить бесконечный ряд констант.

Общая форма для корекурсии -- это метод `unfold` двойственный методу `fold`, его сигнатура:

```
def unfold[A, S](z: S)(f: S => Option[(A, S)]): Stream[A]
```

где `z` -- стартовое значение, `f` -- функция, которая может вернуть пару значений -- значение типа, `A` которое добавится в поток и аккумулирующее значение типа `S`. В случае если она возращает `None` вычисление коданных прекращается. Случай, когда `f` может вернуть `None` называется вырожденным.

Пример использования `unfold` -- последовательность степеней двойки:

```
Stream.unfold(1)((a: Int) => {Some((a,a*2))})
```

**Задание:** Лабораторная находится в [гитхабе](https://github.com/MaCS-Club/ScalaExercises) в ветке `stream`. Она содержит следующие задания:

* Используя `foldRight` реализуйте стандартные функции списка, которые позволят использовать `stream` как монаду. Также напишите:

```
def exists(p: A => Boolean): Boolean

def forAll(f: A => Boolean): Boolean

def headOption: Option[A]
```

функции провреющаю есть ли в потоке элемент удовлетворящую условию, удовлетворяют ли условию все элементы и возвращующую голову списка, когда это возможно. Обратите внмание, что их все можно реализовать через `foldRight`.

* Реализуйте `unfold` и напишите функции возврающающие с его помощью последовательность констант (`const`), натуральные числа начинающейся с заданного (`from`) и последовательность Фибоначи (`fibs`)

* Релизуйте следующие функции

```
def zipWithAll[B, C](s2: Stream[B])(f: (Option[A], Option[B]) => C): Stream[C]

def startsWith[A](s: Stream[A]): Boolean 

def tails: Stream[Stream[A]]

def scanRight[B](z: B)(f: (A, => B) => B): Stream[B] 
```

Функция `zipWithAll` принимает два потока и соединяет их между собой с помощью функции `f`. В случае, если заканчивается хоть один поток -- склейка прекращается.

Функция `startsWith[A]` проверяет начианется ли текущий поток с `s`.

Функция `tails` возвращает все подхвосты текущего потока. например для потока `Stream(1,2,3) она вернет:

```
Stream(Stream(1,2,3),Stream(2,3),Stream(3),Empty)
````

Вместе они позволяют создать поиск подпоследовательности.

Наконец `scanRight` аналогична `foldRight`, но возвращает всю последовательность промежуточных результатов. Можно ли её релизовать используя `unfold`?

Все задания должны быть покрыты тестами.

[Назад](https://macs-club.github.io/ScalaLectures/index)

